# サブエージェント再設計案と /implement コマンドの開発

## 背景と目的

### 達成したいこと（目的）

1. **高品質なコード生成**: 専門化されたエージェントによる品質向上
2. **Human-in-the-loopの維持**: 重要な意思決定ポイントでの人間の関与
3. **効率的な開発フロー**: 繰り返し作業の自動化と並列処理

### メインコンテキスト保護（手段）

上記目的を達成するための手段として、サブエージェントを活用してメインコンテキストを保護する。

> 「複雑なタスクにはX tokens入力＋Y tokens作業＋Z tokens回答が必要。サブエージェントは(X+Y)の作業を委譲し、最終的なZ tokensの回答のみ返すことでメインコンテキストをクリーンに保つ」
> — [PubNub Best Practices](https://www.pubnub.com/blog/best-practices-for-claude-code-sub-agents/)（参考例として引用）

### Boris Cherny（Claude Code創設者）の見解

- サブエージェントは「スラッシュコマンドのように」使うべき
- 「会話やタスクの初期段階で、詳細確認や疑問調査にサブエージェントを活用するとコンテキスト可用性が保持される」
- 5つのClaude並列実行で作業効率化
- `code-simplifier`、`verify-app`などの専門エージェントを活用

参考: [Anthropic Engineering - Claude Code Best Practices](https://www.anthropic.com/engineering/claude-code-best-practices)

---

## /implement コマンドの位置づけ

### /feature-dev との関係

| 観点             | /feature-dev         | /implement                      |
| ---------------- | -------------------- | ------------------------------- |
| **目的**         | 機能開発の全体ガイド | TDD実装に特化                   |
| **実装者**       | メインエージェント   | サブエージェント（implementer） |
| **コンテキスト** | メインに蓄積         | サブエージェントで分散          |
| **対象**         | 新機能開発全般       | 設計済みタスクの実装            |

**関係性**: `/implement` は `/feature-dev` を置き換えるものではなく、**補完的なコマンド**として位置づける。

- `/feature-dev`: 要件理解から設計までをガイド
- `/implement`: 設計済みのタスクをTDDで実装

将来的に `/feature-dev` から `/implement` を呼び出す統合も検討可能。

---

## 設計方針

### Claude Codeの制約

サブエージェントは**メインエージェントから呼び出される**構造であり、サブエージェント間の直接連携はできない。

```
┌─────────────────────────────────────┐
│      Main Agent (Orchestrator)      │
└─────────────────────────────────────┘
    ↓           ↓           ↓
┌─────────┐ ┌─────────┐ ┌─────────┐
│ Agent A │ │ Agent B │ │ Agent C │
└─────────┘ └─────────┘ └─────────┘
```

したがって、パイプライン型もチーム型も**実装上は同じ**（メインエージェントがオーケストレーション）。
違いは**論理的なフェーズ分割**と**エージェントの専門化**にある。

### エージェント定義とコマンドの役割分離

| レイヤー             | ファイル                | 責務                                                             |
| -------------------- | ----------------------- | ---------------------------------------------------------------- |
| **エージェント定義** | `.claude/agents/*.md`   | 各エージェントの専門能力を定義（汎用的、再利用可能）             |
| **コマンド**         | `.claude/commands/*.md` | ワークフローをオーケストレーション（エージェント間の連携を定義） |

**設計方針**:

1. **エージェント定義は変更せず、コマンドがワークフローを定義する**
2. **各エージェントは独立した能力を持つ**（他エージェントへの言及を避ける）
3. **データ受け渡しはfeature-devと同様の直接方式**

### エージェント間のデータ受け渡し

feature-devと同様の方式を採用する：

```
1. サブエージェントを呼び出し
2. サブエージェントは「要約 + 重要ファイルリスト」を返す
3. メインエージェントが重要ファイルを直接読んで理解を深める
4. 次のサブエージェントを呼び出し（必要な情報をプロンプトで渡す）
```

**理由**: コンテキスト保護を意識しすぎると、検討の文脈が限定されすぎて精度が下がる懸念がある。
メインエージェントが文脈を保持しつつ、サブエージェントの専門能力を活用する形が望ましい。

### メインエージェントの役割

メインエージェントは**オーケストレーター**として機能し、以下に集中する：

- サブエージェントの呼び出しと結果の統合
- 人間との対話（質問、確認、承認）
- 全体フローの制御

**実装作業（コーディング）はサブエージェントに委譲**し、メインコンテキストの消費を最小化する。

### Human-in-the-loopの維持

`.claude/rules/ai-auto-pr-workflow-concerns.md` の知見を踏まえ:

- **重要な意思決定ポイント（設計承認、PR作成前）で人間の確認を挟む**
- **implementerはWrite権限を持ち直接コーディングを行う**（効率重視）
- セキュリティ関連コード（認証・決済・個人情報）は人間レビューを必須とする
- 変更後は code-reviewer によるレビューと人間確認で品質を担保

---

## エージェント構成

### /implement で使用するエージェント

| エージェント       | 役割                         | ツール                                | モデル | 状態 |
| ------------------ | ---------------------------- | ------------------------------------- | ------ | ---- |
| **code-explorer**  | 既存コードの調査、パス追跡   | Read, Glob, Grep, WebFetch, WebSearch | sonnet | 既存 |
| **code-architect** | 設計検証、実装ブループリント | Read, Glob, Grep, WebFetch, WebSearch | sonnet | 既存 |
| **implementer**    | TDDによるコード実装          | Read, Glob, Grep, Write, Edit, Bash   | sonnet | 新規 |
| **code-reviewer**  | コードレビュー、バグ検出     | Read, Glob, Grep                      | sonnet | 既存 |

**リファクタリング**: 既存の `/simplify` コマンドを活用（新規エージェント不要）

### ツールアクセス制御

| エージェント   | Read系 | Write系 | Bash | Web |
| -------------- | ------ | ------- | ---- | --- |
| code-explorer  | ✓      | ✗       | ✗    | ✓   |
| code-architect | ✓      | ✗       | ✗    | ✓   |
| implementer    | ✓      | ✓       | ✓    | ✗   |
| code-reviewer  | ✓      | ✗       | ✗    | ✗   |

**設計方針**:

- **implementerにはWrite/Edit/Bash権限を付与**し、直接コーディングを行う
- これはPubNub、Zach Willsなど実践者のベストプラクティスに基づく
- メインエージェントはオーケストレーションに集中し、コンテキスト消費を最小化
- 品質担保はcode-reviewerによるレビューと人間確認で行う

### モデル選択の判断基準

| モデル | 使用条件                                   |
| ------ | ------------------------------------------ |
| opus   | 複雑な判断、創造的な設計が必要な場合       |
| sonnet | 標準的な分析・設計・実装作業（デフォルト） |
| haiku  | 単純なパターンマッチング、定型処理         |

---

## 新規エージェント詳細設計

### implementer（実装）

**役割**:

- code-architectの設計に基づきTDDで実装
- テストコードを先に作成し、振る舞いを定義
- 実装コードを作成し、テストをパスさせる
- 既存パターン・コーディング規約に従う

**ツール権限**: Read, Glob, Grep, **Write, Edit, Bash**（テスト実行用）

**入力**:

- 設計ドキュメント（code-architectの出力）
- 対象ファイルリスト
- 実装の優先順位
- コーディング規約（CLAUDE.mdから）

**TDDフロー**:

```
1. テストファイルを作成（振る舞いを定義）
2. テスト実行 → 失敗を確認（Red）
3. 実装コードを作成
4. テスト実行 → パスを確認（Green）
5. 必要に応じてリファクタリング
```

**出力**:

- 実装済みのコードファイル
- テストファイル
- 実行結果のサマリー

---

## /implement コマンド仕様

### 基本情報

```yaml
name: implement
description: TDDによる実装を専門エージェントで実行
argument-hint: "<設計内容または対象ファイル>"
model: sonnet
```

### ワークフロー

```
Phase 1: コード理解
  └─ code-explorer（2-3並列）
  └─ 既存コードの調査、パス追跡

Phase 2: 設計確認
  └─ code-architect（1-2並列）
  └─ 設計検証、実装ブループリント作成

Phase 3: 計画レビュー（メインエージェント）
  └─ 人間への設計確認 → 承認待ち

Phase 4: TDD実装
  └─ implementer（1-2並列、Write/Edit/Bash権限）
  └─ テスト作成 → 実装 → テスト実行

Phase 5: レビュー
  └─ code-reviewer（3並列）
  └─ 問題があれば Phase 6 へ

Phase 6: 修正（必要に応じて）
  └─ implementer（Write/Edit/Bash権限）
  └─ 修正 → テスト再実行

Phase 7: Simplification（オプション）
  └─ /simplify コマンドを実行
  └─ リファクタリング実行

Phase 8: 結果報告（メインエージェント）
  └─ 実装サマリー、次のアクション提示
```

### フィードバックループ

```
┌─────────────────────────────────────────────────────────┐
│                                                         │
│  Phase 4 ←── 失敗 ←── Phase 5 (Review)                 │
│     ↓                                                   │
│  Phase 6 ──→ 問題発見 ──→ Phase 4 へ戻る               │
│     ↓                                                   │
│  Phase 7 ──→ 拒否 ──→ Phase 8 へ（リファクタリングなし）│
│                                                         │
└─────────────────────────────────────────────────────────┘

終了条件:
- テストがすべてパス
- code-reviewerの指摘がすべて解決（または人間が許容）
- /simplify の提案を適用または人間がスキップを選択
```

### 使用例

```bash
# 設計内容を指定して実装
/implement "UserService に退会機能を追加"

# 対象ファイルを指定
/implement src/services/user.ts

# issue番号を指定（code-explorerが調査）
/implement #123
```

---

## リスク対策

### セキュリティ考慮

`.claude/rules/ai-auto-pr-workflow-concerns.md` との整合性:

| リスク                 | 対策                                                        |
| ---------------------- | ----------------------------------------------------------- |
| AI生成コードの脆弱性   | code-reviewerによるレビュー + 人間確認で検出                |
| 任意コマンド実行       | implementerのBash権限はテスト実行に限定（プロンプトで制約） |
| セキュリティ関連コード | 認証・決済・個人情報を扱うコードは必ず人間レビューを挟む    |
| 意図しない変更         | Gitで差分確認、必要に応じてロールバック                     |

### 失敗時のリカバリー

| 失敗パターン             | 対処                                             |
| ------------------------ | ------------------------------------------------ |
| エージェントタイムアウト | メインエージェントがリトライまたは人間に報告     |
| 不適切な出力             | メインエージェントが検証し、再実行または手動対応 |
| 無限ループ               | フィードバックループに最大回数（3回）を設定      |

### 並列実行の制約

| 制約             | 対策                                               |
| ---------------- | -------------------------------------------------- |
| API rate limit   | 同時実行数を5以下に制限                            |
| コンテキスト競合 | 同じファイルを複数エージェントが変更しないよう分離 |
| コスト増加       | モデル選択の最適化、不要な呼び出しの削減           |

---

## 開発計画

### Phase 1: implementer エージェント作成

**目標**: TDD実装を行う専門エージェントを作成

**作業内容**:

1. `.claude/agents/implementer.md` を作成
2. TDDフローの定義
3. ツール権限の設定（Read, Glob, Grep, Write, Edit, Bash）

**成功指標**:

- 単体でTDD実装が正常に動作
- テスト作成 → 実装 → テスト実行のサイクルが完了

### Phase 2: /implement コマンド作成（MVP）

**目標**: 最小限のワークフローで動作確認

**作業内容**:

1. `.claude/commands/implement.md` を作成
2. Phase 1-4 のみ実装（コード理解 → 設計確認 → 承認 → TDD実装）
3. code-reviewerによるレビューは既存を活用
4. /simplify コマンドとの連携

**成功指標**:

- 3つのタスクで /implement が正常動作
- メインエージェントのコンテキスト消費が削減される

**ロールバック基準**:

- implementerの出力が50%以上の確率で使用不可
- レイテンシが2倍以上増加

### Phase 3: 統合と最適化

**目標**: 全体フローの最適化

**作業内容**:

1. フィードバックループの調整
2. 並列実行の最適化
3. ドキュメント整備
4. /feature-dev との連携検討

**成功指標**:

- 実装タスクの総時間が現行比で同等以下
- 品質指標（テストカバレッジ、レビュー指摘数）が改善

---

## コスト分析

### 見積もり（1タスク実装あたり）

| フェーズ | エージェント/コマンド | 推定トークン（入力） | 推定トークン（出力） |
| -------- | --------------------- | -------------------- | -------------------- |
| Phase 1  | code-explorer x3      | 30,000               | 6,000                |
| Phase 2  | code-architect x2     | 20,000               | 6,000                |
| Phase 4  | implementer x2        | 20,000               | 8,000                |
| Phase 5  | code-reviewer x3      | 30,000               | 6,000                |
| Phase 7  | /simplify             | 10,000               | 3,000                |
| **合計** | 11呼び出し            | 110,000              | 29,000               |

**比較**: 現行（メインエージェント集中型）

- 推定: 入力 200,000+ トークン（コンテキスト蓄積）
- 新設計はサブエージェントで分散するため、メインコンテキストの蓄積を抑制

**トレードオフ**:

- API呼び出し回数は増加
- 総トークン数は同程度または減少（コンテキスト再利用の減少）
- レイテンシは並列実行で相殺

---

## 反対意見と対処

### 「サブエージェントがコンテキストをゲートキープするリスク」

**対処**: メインエージェントは常にサブエージェントの出力全体を受け取る。要約や省略はしない設計とする。重要な情報の欠落を防ぐため、出力スキーマに必須フィールドを定義。

### 「人間のワークフローを強制するリスク」

**対処**: フェーズのスキップを許容する設計。緊急時や小規模修正では `--quick` フラグなどで簡略化可能とする。

### 「CLAUDE.mdに全コンテキストを置く代替案」

**対処**: CLAUDE.mdは静的なルールに適しているが、動的な分析結果には不向き。両者を併用する。

---

## 参考資料

### 主要ソース

1. **[Best practices for Claude Code subagents - PubNub](https://www.pubnub.com/blog/best-practices-for-claude-code-sub-agents/)**
   - 3段階パイプラインの一例
   - ツールアクセス制御の考え方
   - **注**: Anthropic公式ではなく、一企業の実践例として参考

2. **[Claude Code Best Practices - Anthropic Engineering](https://www.anthropic.com/engineering/claude-code-best-practices)**（公式）
   - 初期段階でのサブエージェント活用
   - `/clear`コマンドによるコンテキスト管理
   - Git worktreeとの併用

3. **[How to Use Claude Code Subagents to Parallelize Development - Zach Wills](https://zachwills.net/how-to-use-claude-code-subagents-to-parallelize-development/)**
   - 各専門家が独自の200kコンテキストウィンドウを持つ利点

4. **[awesome-claude-code-subagents - VoltAgent](https://github.com/VoltAgent/awesome-claude-code-subagents)**
   - カテゴリ別構成の参考

### 内部参考資料

- `.claude/rules/ai-auto-pr-workflow-concerns.md` - AI生成コードのリスク分析
- `.claude/rules/implementation.md` - 現行ワークフロー定義
- `.claude/commands/feature-dev.md` - 現行の機能開発コマンド

---

## 決定事項

### 決定済み

- [x] **コマンド名**: `/implement`
- [x] **位置づけ**: `/feature-dev` の補完コマンド（置き換えではない）
- [x] **新規エージェント**: implementer のみ（simplifierは /simplify コマンドを活用）
- [x] **設計方針**: implementerにWrite/Edit/Bash権限を付与し、直接コーディングを行う
- [x] **メインエージェントの役割**: オーケストレーション + 人間との対話に集中
- [x] **Human-in-the-loop維持**: 計画レビュー時と最終確認時に人間の承認ポイントを設ける
- [x] **既存エージェント定義は変更しない**: エージェントは汎用的なまま維持
- [x] **コマンドでワークフローを定義**: エージェント間の連携はコマンドが制御
- [x] **各エージェントは独立した能力を持つ**: 他エージェントへの言及を避ける
- [x] **データ受け渡しはfeature-devと同様の直接方式**: 中間ファイルは使わない
- [x] **要件分析はメインエージェントで行う**: spec-analystサブエージェントは不要

### 承認待ち

- [ ] 開発計画の開始（Phase 1から着手）
- [ ] implementer エージェント定義ファイルの作成
- [ ] /implement コマンドファイルの作成

### 今後の検討事項

- [ ] 並列実行数の最適値（3-5の間で調整）
- [ ] コスト監視の仕組み
- [ ] 品質メトリクスの自動収集
- [ ] implementerのBash権限の制約方法（テスト実行のみに限定）
- [ ] /feature-dev との統合（Phase 3以降）

---

_作成日: 2026-01-27_
_最終更新: 2026-01-28_
_ステータス: 設計完了・実装準備中_

## 変更履歴

- 2026-01-28: simplifierサブエージェントを削除、既存の /simplify コマンドを活用する方針に変更
- 2026-01-28: spec-analystはメインエージェントで行う判断を決定事項に追加
- 2026-01-28: 開発計画を Phase 1-3 に簡素化（Phase 3: simplifier追加 を削除）
- 2026-01-27: `/implement` コマンドの開発計画として再構成
- 2026-01-27: /feature-dev との関係を明確化（補完コマンドとして位置づけ）
- 2026-01-27: implementerにWrite/Edit/Bash権限を付与する設計に変更（実践者のベストプラクティスに基づく）
- 2026-01-27: メインエージェントの役割を「オーケストレーション + 人間との対話」に明確化
- 2026-01-27: 「エージェント定義とコマンドの役割分離」を追加。エージェント定義は変更せず、コマンドでワークフローを定義する方針を明確化
- 2026-01-27: エージェント間のデータ受け渡しはfeature-devと同様の直接方式を採用。各エージェントは独立した能力を持ち、他エージェントへの言及を避ける方針を追加
